[
    {
      "question": "What is the primary technique used to detect a loop in a Doubly Linked List (DLL)?",
      "options": {
        "A": "Using two pointers, one slow and one fast (Floyd's Cycle-Finding Algorithm)",
        "B": "Marking visited nodes using an extra field",
        "C": "Using a Hash Set to store visited node addresses",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the time complexity of detecting a loop in a DLL of size 'n' using Floyd's Cycle-Finding Algorithm?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the auxiliary space complexity of detecting a loop in a DLL using Floyd's Cycle-Finding Algorithm?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "A"
    },
    {
      "question": "What is the primary characteristic of a bitonic DLL?",
      "options": {
        "A": "It contains only even numbers.",
        "B": "It is first strictly increasing and then strictly decreasing, or vice-versa.",
        "C": "All nodes are duplicated.",
        "D": "It forms a cycle."
      },
      "correct_answer": "B"
    },
    {
      "question": "What is an efficient time complexity to sort a Bitonic Doubly Linked List of size 'n'?",
      "options": {
        "A": "O(n^2)",
        "B": "O(n log n)",
        "C": "O(n)",
        "D": "O(log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "To segregate even and odd nodes in a Linked List while maintaining relative order, what is a common approach?",
      "options": {
        "A": "Sort the list first.",
        "B": "Use two separate lists (one for even, one for odd) and then concatenate.",
        "C": "Iterate and swap nodes pairwise.",
        "D": "Use a hash map."
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of segregating even and odd nodes in a LL of size 'n' by creating two separate lists and merging?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the auxiliary space complexity of segregating even/odd nodes using the two-list approach (considering only pointers/new list heads)?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "Depends on the number of even nodes"
      },
      "correct_answer": "A"
    },
    {
      "question": "What is the worst-case time complexity of Merge Sort for a Doubly Linked List (DLL) of size 'n'?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the auxiliary space complexity of an efficient Merge Sort implementation for a DLL (considering recursion stack)?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "A 'Minimum Stack' is a data structure that supports push, pop, top, and retrieving the minimum element in what time complexity?",
      "options": {
        "A": "O(n) for all operations",
        "B": "O(log n) for all operations",
        "C": "O(1) for push/pop/top, O(n) for getMin",
        "D": "O(1) for all operations"
      },
      "correct_answer": "D"
    },
    {
      "question": "How can a Minimum Stack be implemented efficiently (O(1) operations)?",
      "options": {
        "A": "By maintaining a sorted list alongside the stack.",
        "B": "By searching the stack for the minimum on each getMin call.",
        "C": "By storing pairs of (element, current_minimum) on the stack OR using an auxiliary stack.",
        "D": "It's not possible to achieve O(1) for all operations."
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the auxiliary space complexity of a Minimum Stack implementation using an auxiliary stack?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
    {
      "question": "In the Celebrity problem (n people), a celebrity is known by everyone but knows no one. What is the minimum number of questions (of the form 'Does A know B?') needed in the worst case using an efficient algorithm?",
      "options": {
        "A": "O(n^2)",
        "B": "O(n log n)",
        "C": "O(n)",
        "D": "O(1)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the time complexity of solving the Celebrity problem using a stack-based approach or elimination?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the auxiliary space complexity of the standard stack-based algorithm for the Celebrity problem?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the total number of moves required to solve the Tower of Hanoi puzzle with 'n' disks?",
      "options": {
        "A": "n - 1",
        "B": "2n - 1",
        "C": "n^2 - 1",
        "D": "2^n - 1"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the time complexity of the standard recursive algorithm for Tower of Hanoi with 'n' disks?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(2^n)",
        "D": "O(n!)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of the standard recursive algorithm for Tower of Hanoi with 'n' disks (considering recursion stack depth)?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(2^n)"
      },
      "correct_answer": "C"
    },
     {
      "question": "The Stock Span problem calculates, for each day, the number of consecutive preceding days where the stock price was less than or equal to the current day's price. Which data structure is most efficient for solving this?",
      "options": {
        "A": "Queue",
        "B": "Stack",
        "C": "Heap",
        "D": "Hash Map"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of the efficient stack-based solution for the Stock Span problem for 'n' days?",
      "options": {
        "A": "O(n^2)",
        "B": "O(n log n)",
        "C": "O(n)",
        "D": "O(log n)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the auxiliary space complexity of the efficient stack-based solution for the Stock Span problem?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
    {
      "question": "Implementing a Priority Queue using a Doubly Linked List (unsorted) results in what time complexities for insertion (enqueue) and extract-min (dequeue)?",
      "options": {
        "A": "Insert: O(1), Extract-Min: O(n)",
        "B": "Insert: O(n), Extract-Min: O(1)",
        "C": "Insert: O(log n), Extract-Min: O(log n)",
        "D": "Insert: O(1), Extract-Min: O(1)"
      },
      "correct_answer": "A"
    },
    {
      "question": "If a Priority Queue is implemented using a *sorted* Doubly Linked List, what are the time complexities for insertion (enqueue) and extract-min (dequeue)?",
      "options": {
        "A": "Insert: O(1), Extract-Min: O(n)",
        "B": "Insert: O(n), Extract-Min: O(1)",
        "C": "Insert: O(log n), Extract-Min: O(log n)",
        "D": "Insert: O(n), Extract-Min: O(n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "Which sorting algorithm inherently sorts an array 'in-place', meaning it requires O(1) auxiliary space (excluding the input array)?",
      "options": {
        "A": "Merge Sort",
        "B": "Heap Sort",
        "C": "Counting Sort",
        "D": "Radix Sort"
      },
      "correct_answer": "B"
    },
    {
      "question": "What does 'Sort without extra Space' typically refer to in the context of array sorting algorithms?",
      "options": {
        "A": "Sorting algorithms with O(n) space complexity.",
        "B": "Sorting algorithms with O(log n) space complexity.",
        "C": "Sorting algorithms with O(1) auxiliary space complexity (in-place).",
        "D": "Sorting algorithms that modify the original array."
      },
      "correct_answer": "C"
    },
    {
      "question": "The Max Sliding Window problem finds the maximum element in all contiguous subarrays of size 'k' in an array of size 'n'. Which data structure facilitates an O(n) solution?",
      "options": {
        "A": "Stack",
        "B": "Max-Heap",
        "C": "Deque (Double-Ended Queue)",
        "D": "Balanced Binary Search Tree"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the time complexity of the efficient Deque-based solution for the Max Sliding Window problem (size 'n' array, window 'k')?",
      "options": {
        "A": "O(n*k)",
        "B": "O(n log k)",
        "C": "O(n log n)",
        "D": "O(n)"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the auxiliary space complexity of the Deque-based solution for the Max Sliding Window problem (window size k)?",
      "options": {
        "A": "O(1)",
        "B": "O(k)",
        "C": "O(n)",
        "D": "O(log k)"
      },
      "correct_answer": "B"
    },
    {
      "question": "If a sequence of push operations is P1, P2, P3 and pop operations is O1, O2, O3, a stack permutation is valid if:",
      "options": {
        "A": "The pops are always in the reverse order of pushes (O1=P3, O2=P2, O3=P1).",
        "B": "The pops can occur interleaved with pushes, maintaining LIFO order for popped elements.",
        "C": "Any permutation of P1, P2, P3 is possible.",
        "D": "The number of pushes equals the number of pops."
      },
      "correct_answer": "B"
    },
    {
      "question": "Given the inorder traversal and preorder traversal of a Binary Search Tree (BST), can the original BST be uniquely reconstructed?",
      "options": {
        "A": "Yes, always.",
        "B": "No, never.",
        "C": "Yes, but only if the BST is complete.",
        "D": "Yes, but only if the BST has no duplicate values."
      },
      "correct_answer": "D"
    },
     {
      "question": "What is the time complexity to reconstruct a BST from its inorder and preorder traversals (assuming 'n' nodes)?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(log n)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the time complexity to reconstruct a BST from its inorder and preorder traversals if a hash map is used to quickly find inorder indices?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(log n)"
      },
      "correct_answer": "A"
    },
    {
      "question": "Which tree traversal strategy is typically used to get the 'Top View' of a Binary Tree?",
      "options": {
        "A": "Level Order Traversal (BFS) keeping track of horizontal distances.",
        "B": "Inorder Traversal.",
        "C": "Preorder Traversal.",
        "D": "Postorder Traversal."
      },
      "correct_answer": "A"
    },
    {
      "question": "Vertical Order Traversal of a Binary Tree typically involves:",
      "options": {
        "A": "Printing nodes level by level.",
        "B": "Printing nodes from top to bottom, column by column.",
        "C": "Printing only the leaf nodes.",
        "D": "Printing nodes in sorted order."
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of Vertical Order Traversal of a Binary Tree with 'n' nodes using Level Order Traversal and a Map?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n) if using TreeMap, O(n) on average if using HashMap",
        "C": "O(n^2)",
        "D": "O(log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "Boundary Traversal of a Binary Tree typically includes which parts?",
      "options": {
        "A": "Only the root node.",
        "B": "Only the leaf nodes.",
        "C": "The left boundary (excluding leaves), all leaf nodes, and the right boundary (excluding leaves) in reverse.",
        "D": "All nodes at the last level."
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the time complexity of Boundary Traversal for a Binary Tree with 'n' nodes?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(Height)"
      },
      "correct_answer": "A"
    },
    {
      "question": "Which data structure is primarily used by Breadth-First Search (BFS)?",
      "options": {
        "A": "Stack",
        "B": "Queue",
        "C": "Priority Queue",
        "D": "Hash Map"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of BFS on a graph represented by an Adjacency List?",
      "options": {
        "A": "O(V)",
        "B": "O(E)",
        "C": "O(V + E)",
        "D": "O(V * E)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the space complexity of BFS on a graph (worst case)?",
      "options": {
        "A": "O(1)",
        "B": "O(log V)",
        "C": "O(V)",
        "D": "O(E)"
      },
      "correct_answer": "C"
    },
    {
      "question": "Which data structure is implicitly used by a recursive Depth-First Search (DFS)?",
      "options": {
        "A": "Queue",
        "B": "Stack (Call Stack)",
        "C": "Heap",
        "D": "Array"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of DFS on a graph represented by an Adjacency Matrix?",
      "options": {
        "A": "O(V)",
        "B": "O(E)",
        "C": "O(V + E)",
        "D": "O(V^2)"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the space complexity of DFS on a graph (worst case, considering recursion depth or explicit stack)?",
      "options": {
        "A": "O(1)",
        "B": "O(log V)",
        "C": "O(V)",
        "D": "O(E)"
      },
      "correct_answer": "C"
    },
    {
      "question": "Dial's Algorithm is an optimization of which algorithm for single-source shortest paths?",
      "options": {
        "A": "Bellman-Ford Algorithm",
        "B": "Floyd-Warshall Algorithm",
        "C": "Dijkstra's Algorithm",
        "D": "Breadth-First Search"
      },
      "correct_answer": "C"
    },
     {
      "question": "Dial's Algorithm is particularly efficient when edge weights are:",
      "options": {
        "A": "Negative",
        "B": "Large integers",
        "C": "Small integers (within a known small range)",
        "D": "Floating-point numbers"
      },
      "correct_answer": "C"
    },
    {
      "question": "If 'W' is the maximum edge weight, what is the time complexity of Dial's algorithm?",
      "options": {
        "A": "O(E + V)",
        "B": "O(E log V)",
        "C": "O(E + V*W)",
        "D": "O(V^2)"
      },
      "correct_answer": "C"
    },
    {
      "question": "The Bellman-Ford algorithm solves the single-source shortest path problem in graphs that may contain:",
      "options": {
        "A": "Only positive edge weights",
        "B": "Negative edge weights (but no negative cycles)",
        "C": "Only non-negative edge weights",
        "D": "Cycles (but only positive weights)"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of the Bellman-Ford algorithm on a graph with V vertices and E edges?",
      "options": {
        "A": "O(V + E)",
        "B": "O(E log V)",
        "C": "O(V * E)",
        "D": "O(V^3)"
      },
      "correct_answer": "C"
    },
    {
      "question": "How does Bellman-Ford detect a negative cycle reachable from the source?",
      "options": {
        "A": "If the shortest path estimate decreases after V iterations.",
        "B": "If the shortest path estimate decreases after V-1 iterations.",
        "C": "If a vertex is visited more than once.",
        "D": "If the graph contains a negative edge."
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the space complexity of the Bellman-Ford algorithm?",
      "options": {
        "A": "O(1)",
        "B": "O(log V)",
        "C": "O(V)",
        "D": "O(E)"
      },
      "correct_answer": "C"
    },
    {
      "question": "Topological Sort is applicable to which type of graphs?",
      "options": {
        "A": "Undirected graphs",
        "B": "Directed Acyclic Graphs (DAGs)",
        "C": "Complete graphs",
        "D": "Weighted graphs"
      },
      "correct_answer": "B"
    },
    {
      "question": "Which algorithm(s) can be used to perform a Topological Sort?",
      "options": {
        "A": "Depth-First Search (DFS)",
        "B": "Breadth-First Search (BFS) based approach (Kahn's Algorithm)",
        "C": "Both A and B",
        "D": "Dijkstra's Algorithm"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the time complexity of Topological Sort using Kahn's algorithm (BFS-based) or DFS on a graph with V vertices and E edges?",
      "options": {
        "A": "O(V * E)",
        "B": "O(V log E)",
        "C": "O(V + E)",
        "D": "O(V^2)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of Topological Sort (using either standard DFS or Kahn's)?",
      "options": {
        "A": "O(1)",
        "B": "O(log V)",
        "C": "O(V)",
        "D": "O(E)"
      },
      "correct_answer": "C"
    },
    {
      "question": "Heap Sort uses which data structure internally?",
      "options": {
        "A": "Stack",
        "B": "Queue",
        "C": "Binary Heap (Max-Heap or Min-Heap)",
        "D": "Balanced BST"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the time complexity of Heap Sort in the worst case for an array of size 'n'?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the auxiliary space complexity of an in-place Heap Sort?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "A"
    },
    {
      "question": "A Binomial Heap is a collection of:",
      "options": {
        "A": "Binary Search Trees",
        "B": "Binomial Trees satisfying the min-heap property",
        "C": "Red-Black Trees",
        "D": "Sorted Arrays"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the primary advantage of a Binomial Heap over a Binary Heap regarding the merge operation?",
      "options": {
        "A": "Merging takes O(1) time.",
        "B": "Merging takes O(log n) time.",
        "C": "Merging takes O(n) time.",
        "D": "Binary Heaps cannot be merged efficiently."
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity for insertion into a Binomial Heap of size 'n' (amortized)?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(log^2 n)"
      },
      "correct_answer": "A"
    },
    {
      "question": "What is the time complexity for finding the minimum element in a Binomial Heap of size 'n'?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(log^2 n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity for deleting the minimum element (extract-min) from a Binomial Heap of size 'n'?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(log^2 n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "A K-ary heap is a heap structure where each node has up to how many children?",
      "options": {
        "A": "2",
        "B": "K",
        "C": "log K",
        "D": "K^2"
      },
      "correct_answer": "B"
    },
    {
      "question": "Compared to a binary heap (K=2), increasing K in a K-ary heap generally:",
      "options": {
        "A": "Increases heap height, speeds up extract-min",
        "B": "Decreases heap height, speeds up extract-min",
        "C": "Increases heap height, slows down extract-min",
        "D": "Decreases heap height, may slow down extract-min (due to more comparisons)"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the time complexity of insert and extract-min in a K-ary heap of 'n' elements?",
      "options": {
        "A": "O(log_K n)",
        "B": "O(K log_K n) for extract-min, O(log_K n) for insert",
        "C": "O(log n)",
        "D": "O(K log n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "A Winner Tree is a data structure primarily used for:",
      "options": {
        "A": "Sorting data",
        "B": "Finding the minimum (or maximum) among a set of elements, especially in external sorting",
        "C": "Implementing dictionaries",
        "D": "Graph traversal"
      },
      "correct_answer": "B"
    },
    {
      "question": "How is the winner determined in a node of a Winner Tree?",
      "options": {
        "A": "By summing the children values",
        "B": "By taking the average of children values",
        "C": "By comparing the children values and promoting the winner (e.g., minimum)",
        "D": "By random selection"
      },
      "correct_answer": "C"
    },
     {
      "question": "What data structure in Java provides sorted key-value pairs based on the natural ordering of keys or a comparator?",
      "options": {
        "A": "HashMap",
        "B": "HashSet",
        "C": "TreeMap",
        "D": "ArrayList"
      },
      "correct_answer": "C"
    },
    {
      "question": "Converting a HashMap to a TreeMap in Java typically involves:",
      "options": {
        "A": "Casting the HashMap to a TreeMap.",
        "B": "Creating a new TreeMap and putting all entries from the HashMap into it.",
        "C": "Sorting the HashMap's internal buckets.",
        "D": "It's not directly possible."
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the time complexity of inserting 'n' elements from a HashMap into a TreeMap?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(1)"
      },
      "correct_answer": "B"
    },
    {
      "question": "Which type of Set in Java maintains the insertion order of elements?",
      "options": {
        "A": "HashSet",
        "B": "TreeSet",
        "C": "LinkedHashSet",
        "D": "EnumSet"
      },
      "correct_answer": "C"
    },
     {
      "question": "Which type of Set in Java guarantees elements are stored in sorted order?",
      "options": {
        "A": "HashSet",
        "B": "TreeSet",
        "C": "LinkedHashSet",
        "D": "CopyOnWriteArraySet"
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the average time complexity for add, remove, and contains operations in a HashSet?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "A"
    },
    {
      "question": "What is the time complexity for add, remove, and contains operations in a TreeSet?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "B"
    },
     {
      "question": "The problem 'Distributing items when a person cannot take more than two items of same type' often relates to which algorithmic concept?",
      "options": {
        "A": "Graph Coloring",
        "B": "Combinatorics / Greedy Approach / Dynamic Programming",
        "C": "Shortest Path Algorithms",
        "D": "String Matching"
      },
      "correct_answer": "B"
    },
    {
      "question": "The basic Fibonacci sequence is defined by the recurrence relation:",
      "options": {
        "A": "F(n) = F(n-1) + F(n-2)",
        "B": "F(n) = F(n-1) * F(n-2)",
        "C": "F(n) = 2*F(n-1)",
        "D": "F(n) = n * F(n-1)"
      },
      "correct_answer": "A"
    },
     {
      "question": "What is the time complexity of calculating the nth Fibonacci number using a simple recursive approach?",
      "options": {
        "A": "O(n)",
        "B": "O(log n)",
        "C": "O(n^2)",
        "D": "O(2^n) (Exponential)"
      },
      "correct_answer": "D"
    },
    {
      "question": "What is the time complexity of calculating the nth Fibonacci number using dynamic programming (memoization or tabulation)?",
      "options": {
        "A": "O(n)",
        "B": "O(log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "A"
    },
     {
      "question": "What is the space complexity of calculating the nth Fibonacci number using tabulation (storing all values up to n)?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of calculating the nth Fibonacci number using tabulation optimized to only store the last two values?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "A"
    },
    {
      "question": "The Longest Common Subsequence (LCS) problem aims to find:",
      "options": {
        "A": "The longest contiguous substring common to two strings.",
        "B": "The longest sequence of characters that appear in the same relative order, but not necessarily contiguous, in both strings.",
        "C": "The shortest sequence common to two strings.",
        "D": "The number of matching characters between two strings."
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the standard time complexity of solving the LCS problem for two strings of length 'm' and 'n' using dynamic programming?",
      "options": {
        "A": "O(m + n)",
        "B": "O(m * n)",
        "C": "O(m log n)",
        "D": "O(2^(m+n))"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the standard space complexity of solving the LCS problem using dynamic programming (storing the DP table)?",
      "options": {
        "A": "O(m + n)",
        "B": "O(m * n)",
        "C": "O(min(m, n))",
        "D": "O(1)"
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the space complexity of solving the LCS problem using dynamic programming optimized to use only two rows (or columns) of the DP table?",
      "options": {
        "A": "O(m + n)",
        "B": "O(m * n)",
        "C": "O(min(m, n))",
        "D": "O(1)"
      },
      "correct_answer": "C"
    },
    {
      "question": "The Longest Increasing Subsequence (LIS) problem for a sequence of length 'n' aims to find the longest subsequence where elements are in:",
      "options": {
        "A": "Strictly decreasing order",
        "B": "Strictly increasing order",
        "C": "Non-decreasing order",
        "D": "Alternating order"
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the time complexity of solving the LIS problem using a standard dynamic programming approach?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the time complexity of solving the LIS problem using an optimized approach involving patience sorting or binary search?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "B"
    },
     {
      "question": "What is the space complexity of the standard O(n^2) DP solution for LIS?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n^2)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of the O(n log n) solution for LIS?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "C"
    },
    {
      "question": "A Longest Bitonic Subsequence is a subsequence that is first __________ and then __________.",
      "options": {
        "A": "increasing, decreasing",
        "B": "decreasing, increasing",
        "C": "constant, increasing",
        "D": "decreasing, constant"
      },
      "correct_answer": "A"
    },
    {
      "question": "The Longest Bitonic Subsequence problem can often be solved by combining the results of:",
      "options": {
        "A": "Two LCS calculations",
        "B": "LIS (Longest Increasing Subsequence) calculated from left-to-right and LDS (Longest Decreasing Subsequence) calculated from right-to-left",
        "C": "Binary search twice",
        "D": "Heap sort and merge sort"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of finding the Longest Bitonic Subsequence of a sequence of length 'n' using the standard LIS/LDS approach?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the time complexity if the O(n log n) LIS/LDS algorithm is used to find the Longest Bitonic Subsequence?",
      "options": {
         "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "The Longest Palindromic Subsequence (LPS) problem is equivalent to finding the LCS between the original sequence and:",
      "options": {
        "A": "Itself",
        "B": "Its reverse",
        "C": "Its sorted version",
        "D": "An empty sequence"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of finding the Longest Palindromic Subsequence for a sequence of length 'n' using dynamic programming?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(2^n)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity for finding the Longest Palindromic Subsequence using the standard DP approach (building the table)?",
      "options": {
         "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n^2)",
        "D": "O(1)"
      },
      "correct_answer": "C"
    },
    {
      "question": "The Subset Sum problem asks if there is a subset of a given set of integers that sums up to:",
      "options": {
        "A": "Zero",
        "B": "A given target value 'T'",
        "C": "The maximum possible value",
        "D": "The minimum positive value"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the time complexity of the standard dynamic programming solution for the Subset Sum problem with 'n' items and target sum 'T'?",
      "options": {
        "A": "O(n + T)",
        "B": "O(n * T)",
        "C": "O(n log T)",
        "D": "O(2^n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "The complexity O(n*T) for Subset Sum is considered pseudo-polynomial because:",
      "options": {
        "A": "It's very fast in practice.",
        "B": "It involves multiplication.",
        "C": "It depends on the magnitude of the target sum 'T', not just the number of items 'n'.",
        "D": "It only works for positive integers."
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of the standard DP solution for Subset Sum?",
      "options": {
        "A": "O(n)",
        "B": "O(T)",
        "C": "O(n * T)",
        "D": "O(n + T)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of the standard DP solution for Subset Sum optimized to use only one row (or O(T) space)?",
      "options": {
        "A": "O(n)",
        "B": "O(T)",
        "C": "O(n * T)",
        "D": "O(1)"
      },
      "correct_answer": "B"
    },
    {
      "question": "The 0/1 Knapsack problem involves selecting items, each with a weight and a value, such that:",
      "options": {
        "A": "The total weight is minimized, and total value is maximized.",
        "B": "The total weight does not exceed a capacity 'W', and the total value is maximized.",
        "C": "You can take fractions of items.",
        "D": "All items must be taken."
      },
      "correct_answer": "B"
    },
     {
      "question": "In the 0/1 Knapsack problem, the '0/1' signifies that:",
      "options": {
        "A": "Items have weights 0 or 1.",
        "B": "Items have values 0 or 1.",
        "C": "You can either take an item entirely (1) or not take it at all (0).",
        "D": "The knapsack capacity is either 0 or 1."
      },
      "correct_answer": "C"
    },
    {
      "question": "What is the standard time complexity of solving the 0/1 Knapsack problem using dynamic programming with 'n' items and capacity 'W'?",
      "options": {
        "A": "O(n + W)",
        "B": "O(n * W)",
        "C": "O(n log W)",
        "D": "O(2^n)"
      },
      "correct_answer": "B"
    },
    {
      "question": "What is the standard space complexity of the dynamic programming solution for the 0/1 Knapsack problem (storing the full DP table)?",
      "options": {
        "A": "O(n)",
        "B": "O(W)",
        "C": "O(n * W)",
        "D": "O(n + W)"
      },
      "correct_answer": "C"
    },
     {
      "question": "What is the space complexity of the dynamic programming solution for the 0/1 Knapsack problem optimized to use O(W) space?",
      "options": {
        "A": "O(n)",
        "B": "O(W)",
        "C": "O(n * W)",
        "D": "O(1)"
      },
      "correct_answer": "B"
    }
  ]