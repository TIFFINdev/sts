<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DS/Algo MCQ Practice</title>
    <style>
        :root {
            --primary-color: #000000;
            --secondary-color: #000000;
            --accent-color: #ae00ff;
            --success-color: #2ecc71;
            --error-color: #e74c3c;
            --background-color: #000000;
            --card-color: #ffffff5c;
            --text-color: #ffffff;
            --border-radius: 8px;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .containe {
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, #00000000, var(--secondary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
        }

        .home-link {
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .home-link svg {
            margin-right: 8px;
        }

        main {
            padding: 40px 0;
        }

        .card {
            background-color: var(--card-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 30px;
            margin-bottom: 30px;
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: var(--secondary-color);
        }

        .card-description {
            margin-bottom: 20px;
            color: #6c757d;
        }

        .options-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:focus {
            outline: none;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .question-card {
            display: flex;
            flex-direction: column;
        }

        .question-number {
            font-size: 20px;
            font-weight: bold;

            color: var(--background-color);
            margin-bottom: 5px;
        }

        .question-text {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .option {
            background-color: #f1f3f546;
            border: 1px solid #dee2e6;
            border-radius: var(--border-radius);
            padding: 12px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover {
            background-color: #e9ecef6d;
        }

        .option.selected {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .option.correct {
            background-color: var(--success-color);
            color: white;
            border-color: var(--success-color);
        }

        .option.incorrect {
            background-color: var(--error-color);
            color: white;
            border-color: var(--error-color);
        }

        .feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: var(--border-radius);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 16px;
            font-weight: 500;
        }

        .feedback.visible {
            opacity: 1;
        }

        .feedback.correct {
            background-color: rgba(255, 255, 255, 0.39);
            color: var(--success-color);
        }

        .feedback.incorrect {
            background-color: rgba(255, 255, 255, 0.345);
            color: var(--error-color);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e9ecef;
            border-radius: 3px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .results {
            text-align: center;
            padding: 20px;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .score-details {
            margin-bottom: 20px;
        }

        .practice-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .options-container {
                grid-template-columns: 1fr;
            }

            .card {
                padding: 20px;
            }

            .question-text {
                font-size: 16px;
            }
        }



        /* From Uiverse.io by SelfMadeSystem */
        /*
More comprehensive version at shenanigans.shoghisimon.ca/collection/css-blur-blob-bg/
 */

        .container::after {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            /* backdrop-filter: hue-rotate(90deg); */
            /* mask: linear-gradient(45deg, #0000, #000); */
            animation: rotaty 5s linear infinite;
            transform-origin: center;
        }

        .container {
            position: absolute;
            /* background-image: radial-gradient(circle at 50% 50%,
                    #0000 0,
                    #0000 2px,
                    hsl(0 0 4%) 2px); */
            background-size: 8px 8px;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        @keyframes thingy {
            0% {
                filter: var(--f) hue-rotate(0deg);
            }

            to {
                filter: var(--f) hue-rotate(1turn);
            }
        }

        .container::before {
            content: "";
            position: absolute;
            inset: -8em;
            z-index: -1;
            --f: blur(7em) brightness(5);
            --c: #09f;
            animation:
                blobs-1e28bd3d 150s linear infinite,
                thingy 5s linear infinite;
            background-color: #000000;
            background-image: radial-gradient(ellipse 66px 50px at 50% 50%,
                    #0f0 0%,
                    transparent 100%),
                radial-gradient(ellipse 77px 60px at 50% 50%, rgb(229, 255, 0) 0%, transparent 100%),
                radial-gradient(ellipse 78px 100px at 50% 50%, #0f0 0%, transparent 100%),
                radial-gradient(ellipse 73px 96px at 50% 50%, #0f0 0%, transparent 100%),
                radial-gradient(ellipse 76px 77px at 50% 50%, #0f0 0%, transparent 100%),
                radial-gradient(ellipse 66px 51px at 50% 50%, #0f0 0%, transparent 100%),
                radial-gradient(ellipse 90px 57px at 50% 50%, #0f0 0%, transparent 100%),
                radial-gradient(ellipse 89px 93px at 50% 50%, #0f0 0%, transparent 100%);
            background-size:
                726px 576px,
                1242px 454px,
                876px 1160px,
                691px 873px,
                914px 550px,
                1159px 340px,
                1017px 831px,
                313px 977px;
        }

        @keyframes blobs-1e28bd3d {
            0% {
                background-position:
                    271px 478px,
                    62px 291px,
                    67px 861px,
                    553px 413px,
                    36px 392px,
                    1077px 226px,
                    400px 799px,
                    7px 264px;
            }

            to {
                background-position:
                    -14975px -2978px,
                    31112px 11187px,
                    -20081px 8981px,
                    11609px -3952px,
                    -12760px 12492px,
                    -9354px 2946px,
                    9553px 21574px,
                    946px 9057px;
            }
        }
    </style>
</head>

<body>
    <div class="container"></div>
    <header>
        <div class="containe header-content" style="position: relative; z-index: 100;">
            <div class="logo">AT$</div>
            <a href="#" class="home-link" id="homeButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path
                        d="M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L8 2.207l6.646 6.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.707 1.5Z" />
                    <path d="m8 3.293 6 6V13.5a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 13.5V9.293l6-6Z" />
                </svg>
                Home
            </a>
        </div>
    </header>

    <main style=" position: relative;z-index: 100; width: 100%;">
        <div class="containe" id="mainContent" >
            <!-- Home View -->
            <div id="homeView" >
                <h1 style="text-align: center; margin-bottom: 30px;">Advanced Competitive Coding Practice</h1>
                <div class="options-container">
                    <div class="card">
                        <h2 class="card-title">Mock MCQ Exam</h2>
                        <p class="card-description" style="color: white;">Take a timed mock exam with 30 random questions to test your
                            knowledge.</p>
                        <button class="btn btn-block" id="startMockExam">Start Mock Exam</button>
                    </div>
                    <div class="card">
                        <h2 class="card-title">Practice All Questions</h2>
                        <p class="card-description" style="color: white;">Go through all questions at your own pace with instant feedback.</p>
                        <button class="btn btn-block" id="startPractice">Start Practice</button>
                    </div>
                </div>
            </div>

            <!-- Mock Exam View -->
            <div id="mockExamView" style="display: none;">
                <div class="progress-bar">
                    <div class="progress" id="mockProgress"></div>
                </div>
                <div class="card question-card">
                    <div class="question-number" id="mockQuestionNumber">Question 1/30</div>
                    <div class="question-text" id="mockQuestionText"></div>
                    <div class="options" id="mockOptions"></div>
                    <div class="feedback" id="mockFeedback"></div>
                    <div class="navigation">
                        <button class="btn" id="mockNextButton" style="margin-left: auto;">Next Question</button>
                    </div>
                </div>
            </div>

            <!-- Practice View -->
            <div id="practiceView" style="display: none;">
                <div class="card question-card">
                    <div class="question-number" id="practiceQuestionNumber">Question 1</div>
                    <div class="question-text" id="practiceQuestionText"></div>
                    <div class="options" id="practiceOptions"></div>
                    <div class="feedback" id="practiceFeedback"></div>
                    <div class="practice-controls">
                        <button class="btn" id="practicePrevButton" disabled>Previous</button>
                        <button class="btn" id="practiceNextButton">Next</button>
                    </div>
                </div>
            </div>

            <!-- Results View -->
            <div id="resultsView" style="display: none;">
                <div class="card">
                    <div class="results">
                        <h2 class="card-title">Mock Exam Results</h2>
                        <div class="score" id="scoreDisplay"></div>
                        <div class="score-details" id="scoreDetails"></div>
                        <button class="btn" id="retryButton">Try Again</button>
                        <button class="btn" id="homeFromResultsButton" style="margin-left: 10px;">Back to Home</button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Store all questions 
        let allQuestions = [];
        let mockQuestions = [];
        let currentMockQuestion = 0;
        let currentPracticeQuestion = 0;
        let mockAnswers = [];
        let mockCorrectAnswers = 0;

        // DOM Elements
        const homeView = document.getElementById('homeView');
        const mockExamView = document.getElementById('mockExamView');
        const practiceView = document.getElementById('practiceView');
        const resultsView = document.getElementById('resultsView');

        // Buttons
        const startMockExamButton = document.getElementById('startMockExam');
        const startPracticeButton = document.getElementById('startPractice');
        const mockNextButton = document.getElementById('mockNextButton');
        const practicePrevButton = document.getElementById('practicePrevButton');
        const practiceNextButton = document.getElementById('practiceNextButton');
        const retryButton = document.getElementById('retryButton');
        const homeButton = document.getElementById('homeButton');
        const homeFromResultsButton = document.getElementById('homeFromResultsButton');

        // Mock Elements
        const mockQuestionNumber = document.getElementById('mockQuestionNumber');
        const mockQuestionText = document.getElementById('mockQuestionText');
        const mockOptions = document.getElementById('mockOptions');
        const mockFeedback = document.getElementById('mockFeedback');
        const mockProgress = document.getElementById('mockProgress');

        // Practice Elements
        const practiceQuestionNumber = document.getElementById('practiceQuestionNumber');
        const practiceQuestionText = document.getElementById('practiceQuestionText');
        const practiceOptions = document.getElementById('practiceOptions');
        const practiceFeedback = document.getElementById('practiceFeedback');

        // Results Elements
        const scoreDisplay = document.getElementById('scoreDisplay');
        const scoreDetails = document.getElementById('scoreDetails');

        // Load questions
        async function loadQuestions() {
            try {
                // Simulate loading from a file
                // In a real application, you would fetch this from your server
                allQuestions = [
                    {
                        "question": "What is the primary technique used to detect a loop in a Doubly Linked List (DLL)?",
                        "options": {
                            "A": "Using two pointers, one slow and one fast (Floyd's Cycle-Finding Algorithm)",
                            "B": "Marking visited nodes using an extra field",
                            "C": "Using a Hash Set to store visited node addresses",
                            "D": "All of the above"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the time complexity of detecting a loop in a DLL of size 'n' using Floyd's Cycle-Finding Algorithm?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the auxiliary space complexity of detecting a loop in a DLL using Floyd's Cycle-Finding Algorithm?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the primary characteristic of a bitonic DLL?",
                        "options": {
                            "A": "It contains only even numbers.",
                            "B": "It is first strictly increasing and then strictly decreasing, or vice-versa.",
                            "C": "All nodes are duplicated.",
                            "D": "It forms a cycle."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is an efficient time complexity to sort a Bitonic Doubly Linked List of size 'n'?",
                        "options": {
                            "A": "O(n^2)",
                            "B": "O(n log n)",
                            "C": "O(n)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "To segregate even and odd nodes in a Linked List while maintaining relative order, what is a common approach?",
                        "options": {
                            "A": "Sort the list first.",
                            "B": "Use two separate lists (one for even, one for odd) and then concatenate.",
                            "C": "Iterate and swap nodes pairwise.",
                            "D": "Use a hash map."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of segregating even and odd nodes in a LL of size 'n' by creating two separate lists and merging?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the auxiliary space complexity of segregating even/odd nodes using the two-list approach (considering only pointers/new list heads)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "Depends on the number of even nodes"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the worst-case time complexity of Merge Sort for a Doubly Linked List (DLL) of size 'n'?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the auxiliary space complexity of an efficient Merge Sort implementation for a DLL (considering recursion stack)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "A 'Minimum Stack' is a data structure that supports push, pop, top, and retrieving the minimum element in what time complexity?",
                        "options": {
                            "A": "O(n) for all operations",
                            "B": "O(log n) for all operations",
                            "C": "O(1) for push/pop/top, O(n) for getMin",
                            "D": "O(1) for all operations"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "How can a Minimum Stack be implemented efficiently (O(1) operations)?",
                        "options": {
                            "A": "By maintaining a sorted list alongside the stack.",
                            "B": "By searching the stack for the minimum on each getMin call.",
                            "C": "By storing pairs of (element, current_minimum) on the stack OR using an auxiliary stack.",
                            "D": "It's not possible to achieve O(1) for all operations."
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the auxiliary space complexity of a Minimum Stack implementation using an auxiliary stack?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "In the Celebrity problem (n people), a celebrity is known by everyone but knows no one. What is the minimum number of questions (of the form 'Does A know B?') needed in the worst case using an efficient algorithm?",
                        "options": {
                            "A": "O(n^2)",
                            "B": "O(n log n)",
                            "C": "O(n)",
                            "D": "O(1)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of solving the Celebrity problem using a stack-based approach or elimination?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the auxiliary space complexity of the standard stack-based algorithm for the Celebrity problem?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the total number of moves required to solve the Tower of Hanoi puzzle with 'n' disks?",
                        "options": {
                            "A": "n - 1",
                            "B": "2n - 1",
                            "C": "n^2 - 1",
                            "D": "2^n - 1"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the time complexity of the standard recursive algorithm for Tower of Hanoi with 'n' disks?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(2^n)",
                            "D": "O(n!)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of the standard recursive algorithm for Tower of Hanoi with 'n' disks (considering recursion stack depth)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "The Stock Span problem calculates, for each day, the number of consecutive preceding days where the stock price was less than or equal to the current day's price. Which data structure is most efficient for solving this?",
                        "options": {
                            "A": "Queue",
                            "B": "Stack",
                            "C": "Heap",
                            "D": "Hash Map"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of the efficient stack-based solution for the Stock Span problem for 'n' days?",
                        "options": {
                            "A": "O(n^2)",
                            "B": "O(n log n)",
                            "C": "O(n)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the auxiliary space complexity of the efficient stack-based solution for the Stock Span problem?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Implementing a Priority Queue using a Doubly Linked List (unsorted) results in what time complexities for insertion (enqueue) and extract-min (dequeue)?",
                        "options": {
                            "A": "Insert: O(1), Extract-Min: O(n)",
                            "B": "Insert: O(n), Extract-Min: O(1)",
                            "C": "Insert: O(log n), Extract-Min: O(log n)",
                            "D": "Insert: O(1), Extract-Min: O(1)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "If a Priority Queue is implemented using a *sorted* Doubly Linked List, what are the time complexities for insertion (enqueue) and extract-min (dequeue)?",
                        "options": {
                            "A": "Insert: O(1), Extract-Min: O(n)",
                            "B": "Insert: O(n), Extract-Min: O(1)",
                            "C": "Insert: O(log n), Extract-Min: O(log n)",
                            "D": "Insert: O(n), Extract-Min: O(n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Which sorting algorithm inherently sorts an array 'in-place', meaning it requires O(1) auxiliary space (excluding the input array)?",
                        "options": {
                            "A": "Merge Sort",
                            "B": "Heap Sort",
                            "C": "Counting Sort",
                            "D": "Radix Sort"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What does 'Sort without extra Space' typically refer to in the context of array sorting algorithms?",
                        "options": {
                            "A": "Sorting algorithms with O(n) space complexity.",
                            "B": "Sorting algorithms with O(log n) space complexity.",
                            "C": "Sorting algorithms with O(1) auxiliary space complexity (in-place).",
                            "D": "Sorting algorithms that modify the original array."
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "The Max Sliding Window problem finds the maximum element in all contiguous subarrays of size 'k' in an array of size 'n'. Which data structure facilitates an O(n) solution?",
                        "options": {
                            "A": "Stack",
                            "B": "Max-Heap",
                            "C": "Deque (Double-Ended Queue)",
                            "D": "Balanced Binary Search Tree"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of the efficient Deque-based solution for the Max Sliding Window problem (size 'n' array, window 'k')?",
                        "options": {
                            "A": "O(n*k)",
                            "B": "O(n log k)",
                            "C": "O(n log n)",
                            "D": "O(n)"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the auxiliary space complexity of the Deque-based solution for the Max Sliding Window problem (window size k)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(k)",
                            "C": "O(n)",
                            "D": "O(log k)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "If a sequence of push operations is P1, P2, P3 and pop operations is O1, O2, O3, a stack permutation is valid if:",
                        "options": {
                            "A": "The pops are always in the reverse order of pushes (O1=P3, O2=P2, O3=P1).",
                            "B": "The pops can occur interleaved with pushes, maintaining LIFO order for popped elements.",
                            "C": "Any permutation of P1, P2, P3 is possible.",
                            "D": "The number of pushes equals the number of pops."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Given the inorder traversal and preorder traversal of a Binary Search Tree (BST), can the original BST be uniquely reconstructed?",
                        "options": {
                            "A": "Yes, always.",
                            "B": "No, never.",
                            "C": "Yes, but only if the BST is complete.",
                            "D": "Yes, but only if the BST has no duplicate values."
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the time complexity to reconstruct a BST from its inorder and preorder traversals (assuming 'n' nodes)?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity to reconstruct a BST from its inorder and preorder traversals if a hash map is used to quickly find inorder indices?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "Which tree traversal strategy is typically used to get the 'Top View' of a Binary Tree?",
                        "options": {
                            "A": "Level Order Traversal (BFS) keeping track of horizontal distances.",
                            "B": "Inorder Traversal.",
                            "C": "Preorder Traversal.",
                            "D": "Postorder Traversal."
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "Vertical Order Traversal of a Binary Tree typically involves:",
                        "options": {
                            "A": "Printing nodes level by level.",
                            "B": "Printing nodes from top to bottom, column by column.",
                            "C": "Printing only the leaf nodes.",
                            "D": "Printing nodes in sorted order."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of Vertical Order Traversal of a Binary Tree with 'n' nodes using Level Order Traversal and a Map?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n) if using TreeMap, O(n) on average if using HashMap",
                            "C": "O(n^2)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Boundary Traversal of a Binary Tree typically includes which parts?",
                        "options": {
                            "A": "Only the root node.",
                            "B": "Only the leaf nodes.",
                            "C": "The left boundary (excluding leaves), all leaf nodes, and the right boundary (excluding leaves) in reverse.",
                            "D": "All nodes at the last level."
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of Boundary Traversal for a Binary Tree with 'n' nodes?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(Height)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "Which data structure is primarily used by Breadth-First Search (BFS)?",
                        "options": {
                            "A": "Stack",
                            "B": "Queue",
                            "C": "Priority Queue",
                            "D": "Hash Map"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of BFS on a graph represented by an Adjacency List?",
                        "options": {
                            "A": "O(V)",
                            "B": "O(E)",
                            "C": "O(V + E)",
                            "D": "O(V * E)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of BFS on a graph (worst case)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log V)",
                            "C": "O(V)",
                            "D": "O(E)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Which data structure is implicitly used by a recursive Depth-First Search (DFS)?",
                        "options": {
                            "A": "Queue",
                            "B": "Stack (Call Stack)",
                            "C": "Heap",
                            "D": "Array"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of DFS on a graph represented by an Adjacency Matrix?",
                        "options": {
                            "A": "O(V)",
                            "B": "O(E)",
                            "C": "O(V + E)",
                            "D": "O(V^2)"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the space complexity of DFS on a graph (worst case, considering recursion depth or explicit stack)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log V)",
                            "C": "O(V)",
                            "D": "O(E)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Dial's Algorithm is an optimization of which algorithm for single-source shortest paths?",
                        "options": {
                            "A": "Bellman-Ford Algorithm",
                            "B": "Floyd-Warshall Algorithm",
                            "C": "Dijkstra's Algorithm",
                            "D": "Breadth-First Search"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Dial's Algorithm is particularly efficient when edge weights are:",
                        "options": {
                            "A": "Negative",
                            "B": "Large integers",
                            "C": "Small integers (within a known small range)",
                            "D": "Floating-point numbers"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "If 'W' is the maximum edge weight, what is the time complexity of Dial's algorithm?",
                        "options": {
                            "A": "O(E + V)",
                            "B": "O(E log V)",
                            "C": "O(E + V*W)",
                            "D": "O(V^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "The Bellman-Ford algorithm solves the single-source shortest path problem in graphs that may contain:",
                        "options": {
                            "A": "Only positive edge weights",
                            "B": "Negative edge weights (but no negative cycles)",
                            "C": "Only non-negative edge weights",
                            "D": "Cycles (but only positive weights)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of the Bellman-Ford algorithm on a graph with V vertices and E edges?",
                        "options": {
                            "A": "O(V + E)",
                            "B": "O(E log V)",
                            "C": "O(V * E)",
                            "D": "O(V^3)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "How does Bellman-Ford detect a negative cycle reachable from the source?",
                        "options": {
                            "A": "If the shortest path estimate decreases after V iterations.",
                            "B": "If the shortest path estimate decreases after V-1 iterations.",
                            "C": "If a vertex is visited more than once.",
                            "D": "If the graph contains a negative edge."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the space complexity of the Bellman-Ford algorithm?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log V)",
                            "C": "O(V)",
                            "D": "O(E)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Topological Sort is applicable to which type of graphs?",
                        "options": {
                            "A": "Undirected graphs",
                            "B": "Directed Acyclic Graphs (DAGs)",
                            "C": "Complete graphs",
                            "D": "Weighted graphs"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Which algorithm(s) can be used to perform a Topological Sort?",
                        "options": {
                            "A": "Depth-First Search (DFS)",
                            "B": "Breadth-First Search (BFS) based approach (Kahn's Algorithm)",
                            "C": "Both A and B",
                            "D": "Dijkstra's Algorithm"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of Topological Sort using Kahn's algorithm (BFS-based) or DFS on a graph with V vertices and E edges?",
                        "options": {
                            "A": "O(V * E)",
                            "B": "O(V log E)",
                            "C": "O(V + E)",
                            "D": "O(V^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of Topological Sort (using either standard DFS or Kahn's)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log V)",
                            "C": "O(V)",
                            "D": "O(E)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Heap Sort uses which data structure internally?",
                        "options": {
                            "A": "Stack",
                            "B": "Queue",
                            "C": "Binary Heap (Max-Heap or Min-Heap)",
                            "D": "Balanced BST"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of Heap Sort in the worst case for an array of size 'n'?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the auxiliary space complexity of an in-place Heap Sort?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "A Binomial Heap is a collection of:",
                        "options": {
                            "A": "Binary Search Trees",
                            "B": "Binomial Trees satisfying the min-heap property",
                            "C": "Red-Black Trees",
                            "D": "Sorted Arrays"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the primary advantage of a Binomial Heap over a Binary Heap regarding the merge operation?",
                        "options": {
                            "A": "Merging takes O(1) time.",
                            "B": "Merging takes O(log n) time.",
                            "C": "Merging takes O(n) time.",
                            "D": "Binary Heaps cannot be merged efficiently."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity for insertion into a Binomial Heap of size 'n' (amortized)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(log^2 n)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the time complexity for finding the minimum element in a Binomial Heap of size 'n'?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(log^2 n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity for deleting the minimum element (extract-min) from a Binomial Heap of size 'n'?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(log^2 n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "A K-ary heap is a heap structure where each node has up to how many children?",
                        "options": {
                            "A": "2",
                            "B": "K",
                            "C": "log K",
                            "D": "K^2"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Compared to a binary heap (K=2), increasing K in a K-ary heap generally:",
                        "options": {
                            "A": "Increases heap height, speeds up extract-min",
                            "B": "Decreases heap height, speeds up extract-min",
                            "C": "Increases heap height, slows down extract-min",
                            "D": "Decreases heap height, may slow down extract-min (due to more comparisons)"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the time complexity of insert and extract-min in a K-ary heap of 'n' elements?",
                        "options": {
                            "A": "O(log_K n)",
                            "B": "O(K log_K n) for extract-min, O(log_K n) for insert",
                            "C": "O(log n)",
                            "D": "O(K log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "A Winner Tree is a data structure primarily used for:",
                        "options": {
                            "A": "Sorting data",
                            "B": "Finding the minimum (or maximum) among a set of elements, especially in external sorting",
                            "C": "Implementing dictionaries",
                            "D": "Graph traversal"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "How is the winner determined in a node of a Winner Tree?",
                        "options": {
                            "A": "By summing the children values",
                            "B": "By taking the average of children values",
                            "C": "By comparing the children values and promoting the winner (e.g., minimum)",
                            "D": "By random selection"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What data structure in Java provides sorted key-value pairs based on the natural ordering of keys or a comparator?",
                        "options": {
                            "A": "HashMap",
                            "B": "HashSet",
                            "C": "TreeMap",
                            "D": "ArrayList"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Converting a HashMap to a TreeMap in Java typically involves:",
                        "options": {
                            "A": "Casting the HashMap to a TreeMap.",
                            "B": "Creating a new TreeMap and putting all entries from the HashMap into it.",
                            "C": "Sorting the HashMap's internal buckets.",
                            "D": "It's not directly possible."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of inserting 'n' elements from a HashMap into a TreeMap?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(1)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "Which type of Set in Java maintains the insertion order of elements?",
                        "options": {
                            "A": "HashSet",
                            "B": "TreeSet",
                            "C": "LinkedHashSet",
                            "D": "EnumSet"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "Which type of Set in Java guarantees elements are stored in sorted order?",
                        "options": {
                            "A": "HashSet",
                            "B": "TreeSet",
                            "C": "LinkedHashSet",
                            "D": "CopyOnWriteArraySet"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the average time complexity for add, remove, and contains operations in a HashSet?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the time complexity for add, remove, and contains operations in a TreeSet?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "The problem 'Distributing items when a person cannot take more than two items of same type' often relates to which algorithmic concept?",
                        "options": {
                            "A": "Graph Coloring",
                            "B": "Combinatorics / Greedy Approach / Dynamic Programming",
                            "C": "Shortest Path Algorithms",
                            "D": "String Matching"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "The basic Fibonacci sequence is defined by the recurrence relation:",
                        "options": {
                            "A": "F(n) = F(n-1) + F(n-2)",
                            "B": "F(n) = F(n-1) * F(n-2)",
                            "C": "F(n) = 2*F(n-1)",
                            "D": "F(n) = n * F(n-1)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the time complexity of calculating the nth Fibonacci number using a simple recursive approach?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n) (Exponential)"
                        },
                        "correct_answer": "D"
                    },
                    {
                        "question": "What is the time complexity of calculating the nth Fibonacci number using dynamic programming (memoization or tabulation)?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "What is the space complexity of calculating the nth Fibonacci number using tabulation (storing all values up to n)?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of calculating the nth Fibonacci number using tabulation optimized to only store the last two values?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "The Longest Common Subsequence (LCS) problem aims to find:",
                        "options": {
                            "A": "The longest contiguous substring common to two strings.",
                            "B": "The longest sequence of characters that appear in the same relative order, but not necessarily contiguous, in both strings.",
                            "C": "The shortest sequence common to two strings.",
                            "D": "The number of matching characters between two strings."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the standard time complexity of solving the LCS problem for two strings of length 'm' and 'n' using dynamic programming?",
                        "options": {
                            "A": "O(m + n)",
                            "B": "O(m * n)",
                            "C": "O(m log n)",
                            "D": "O(2^(m+n))"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the standard space complexity of solving the LCS problem using dynamic programming (storing the DP table)?",
                        "options": {
                            "A": "O(m + n)",
                            "B": "O(m * n)",
                            "C": "O(min(m, n))",
                            "D": "O(1)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the space complexity of solving the LCS problem using dynamic programming optimized to use only two rows (or columns) of the DP table?",
                        "options": {
                            "A": "O(m + n)",
                            "B": "O(m * n)",
                            "C": "O(min(m, n))",
                            "D": "O(1)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "The Longest Increasing Subsequence (LIS) problem for a sequence of length 'n' aims to find the longest subsequence where elements are in:",
                        "options": {
                            "A": "Strictly decreasing order",
                            "B": "Strictly increasing order",
                            "C": "Non-decreasing order",
                            "D": "Alternating order"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of solving the LIS problem using a standard dynamic programming approach?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity of solving the LIS problem using an optimized approach involving patience sorting or binary search?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the space complexity of the standard O(n^2) DP solution for LIS?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n^2)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of the O(n log n) solution for LIS?",
                        "options": {
                            "A": "O(1)",
                            "B": "O(log n)",
                            "C": "O(n)",
                            "D": "O(n log n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "A Longest Bitonic Subsequence is a subsequence that is first __________ and then __________.",
                        "options": {
                            "A": "increasing, decreasing",
                            "B": "decreasing, increasing",
                            "C": "constant, increasing",
                            "D": "decreasing, constant"
                        },
                        "correct_answer": "A"
                    },
                    {
                        "question": "The Longest Bitonic Subsequence problem can often be solved by combining the results of:",
                        "options": {
                            "A": "Two LCS calculations",
                            "B": "LIS (Longest Increasing Subsequence) calculated from left-to-right and LDS (Longest Decreasing Subsequence) calculated from right-to-left",
                            "C": "Binary search twice",
                            "D": "Heap sort and merge sort"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of finding the Longest Bitonic Subsequence of a sequence of length 'n' using the standard LIS/LDS approach?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the time complexity if the O(n log n) LIS/LDS algorithm is used to find the Longest Bitonic Subsequence?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "The Longest Palindromic Subsequence (LPS) problem is equivalent to finding the LCS between the original sequence and:",
                        "options": {
                            "A": "Itself",
                            "B": "Its reverse",
                            "C": "Its sorted version",
                            "D": "An empty sequence"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of finding the Longest Palindromic Subsequence for a sequence of length 'n' using dynamic programming?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity for finding the Longest Palindromic Subsequence using the standard DP approach (building the table)?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(n log n)",
                            "C": "O(n^2)",
                            "D": "O(1)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "The Subset Sum problem asks if there is a subset of a given set of integers that sums up to:",
                        "options": {
                            "A": "Zero",
                            "B": "A given target value 'T'",
                            "C": "The maximum possible value",
                            "D": "The minimum positive value"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the time complexity of the standard dynamic programming solution for the Subset Sum problem with 'n' items and target sum 'T'?",
                        "options": {
                            "A": "O(n + T)",
                            "B": "O(n * T)",
                            "C": "O(n log T)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "The complexity O(n*T) for Subset Sum is considered pseudo-polynomial because:",
                        "options": {
                            "A": "It's very fast in practice.",
                            "B": "It involves multiplication.",
                            "C": "It depends on the magnitude of the target sum 'T', not just the number of items 'n'.",
                            "D": "It only works for positive integers."
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of the standard DP solution for Subset Sum?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(T)",
                            "C": "O(n * T)",
                            "D": "O(n + T)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of the standard DP solution for Subset Sum optimized to use only one row (or O(T) space)?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(T)",
                            "C": "O(n * T)",
                            "D": "O(1)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "The 0/1 Knapsack problem involves selecting items, each with a weight and a value, such that:",
                        "options": {
                            "A": "The total weight is minimized, and total value is maximized.",
                            "B": "The total weight does not exceed a capacity 'W', and the total value is maximized.",
                            "C": "You can take fractions of items.",
                            "D": "All items must be taken."
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "In the 0/1 Knapsack problem, the '0/1' signifies that:",
                        "options": {
                            "A": "Items have weights 0 or 1.",
                            "B": "Items have values 0 or 1.",
                            "C": "You can either take an item entirely (1) or not take it at all (0).",
                            "D": "The knapsack capacity is either 0 or 1."
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the standard time complexity of solving the 0/1 Knapsack problem using dynamic programming with 'n' items and capacity 'W'?",
                        "options": {
                            "A": "O(n + W)",
                            "B": "O(n * W)",
                            "C": "O(n log W)",
                            "D": "O(2^n)"
                        },
                        "correct_answer": "B"
                    },
                    {
                        "question": "What is the standard space complexity of the dynamic programming solution for the 0/1 Knapsack problem (storing the full DP table)?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(W)",
                            "C": "O(n * W)",
                            "D": "O(n + W)"
                        },
                        "correct_answer": "C"
                    },
                    {
                        "question": "What is the space complexity of the dynamic programming solution for the 0/1 Knapsack problem optimized to use O(W) space?",
                        "options": {
                            "A": "O(n)",
                            "B": "O(W)",
                            "C": "O(n * W)",
                            "D": "O(1)"
                        },
                        "correct_answer": "B"
                    }
                ]


                // In a real app, you would have your full JSON data here
                // or load it from an external file

                return true;
            } catch (error) {
                console.error('Error loading questions:', error);
                return false;
            }
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Start Mock Exam
        function startMockExam() {
            // Reset state
            currentMockQuestion = 0;
            mockAnswers = [];
            mockCorrectAnswers = 0;

            // Select 30 random questions (or all if less than 30)
            const shuffled = shuffleArray([...allQuestions]);
            mockQuestions = shuffled.slice(0, Math.min(30, shuffled.length));

            // Initialize mock answers array
            mockAnswers = Array(mockQuestions.length).fill(null);

            // Switch to mock exam view
            homeView.style.display = 'none';
            mockExamView.style.display = 'block';

            // Display first question
            displayMockQuestion();
        }

        // Display current mock question
        function displayMockQuestion() {
            const question = mockQuestions[currentMockQuestion];
            mockQuestionNumber.textContent = `Question ${currentMockQuestion + 1}/${mockQuestions.length}`;
            mockQuestionText.textContent = question.question;

            // Update progress bar
            mockProgress.style.width = `${((currentMockQuestion + 1) / mockQuestions.length) * 100}%`;

            // Clear options and feedback
            mockOptions.innerHTML = '';
            mockFeedback.innerHTML = '';
            mockFeedback.className = 'feedback';

            // Add options
            for (const [key, value] of Object.entries(question.options)) {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                optionElement.textContent = `${key}: ${value}`;
                optionElement.dataset.option = key;

                optionElement.addEventListener('click', function () {
                    // Prevent selecting if already answered
                    if (mockAnswers[currentMockQuestion] !== null) return;

                    // Record answer
                    mockAnswers[currentMockQuestion] = key;

                    // Check if correct
                    const isCorrect = key === question.correct_answer;
                    if (isCorrect) mockCorrectAnswers++;

                    // Mark options
                    document.querySelectorAll('#mockOptions .option').forEach(opt => {
                        if (opt.dataset.option === key) {
                            opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                        }
                        if (opt.dataset.option === question.correct_answer && !isCorrect) {
                            opt.classList.add('correct');
                        }
                    });

                    // Show feedback
                    mockFeedback.className = `feedback visible ${isCorrect ? 'correct' : 'incorrect'}`;
                    mockFeedback.textContent = isCorrect ?
                        'Correct! Well done.' :
                        `Incorrect. The correct answer is ${question.correct_answer}.`;
                });

                mockOptions.appendChild(optionElement);
            }

            // Update next button text for last question
            if (currentMockQuestion === mockQuestions.length - 1) {
                mockNextButton.textContent = 'Finish Exam';
            } else {
                mockNextButton.textContent = 'Next Question';
            }
        }

        // Handle mock next button
        function handleMockNext() {
            // If no answer selected, prompt user
            if (mockAnswers[currentMockQuestion] === null) {
                // Automatically select an answer if none selected
                const randomOption = Object.keys(mockQuestions[currentMockQuestion].options)[0];
                document.querySelector(`#mockOptions .option[data-option="${randomOption}"]`).click();
                return;
            }

            // If last question, show results
            if (currentMockQuestion === mockQuestions.length - 1) {
                showResults();
                return;
            }

            // Move to next question
            currentMockQuestion++;
            displayMockQuestion();
        }

        // Show exam results
        function showResults() {
            mockExamView.style.display = 'none';
            resultsView.style.display = 'block';

            const score = Math.round((mockCorrectAnswers / mockQuestions.length) * 100);
            scoreDisplay.textContent = `Your Score: ${score}%`;
            scoreDetails.textContent = `You got ${mockCorrectAnswers} out of ${mockQuestions.length} questions correct.`;
        }

        // Start Practice
        function startPractice() {
            // Reset state
            currentPracticeQuestion = 0;

            // Switch to practice view
            homeView.style.display = 'none';
            practiceView.style.display = 'block';

            // Display first question
            displayPracticeQuestion();
        }

        // Display practice question
        function displayPracticeQuestion() {
            const question = allQuestions[currentPracticeQuestion];
            practiceQuestionNumber.textContent = `Question ${currentPracticeQuestion + 1}/${allQuestions.length}`;
            practiceQuestionText.textContent = question.question;

            // Clear options and feedback
            practiceOptions.innerHTML = '';
            practiceFeedback.innerHTML = '';
            practiceFeedback.className = 'feedback';

            // Reset all options
            for (const [key, value] of Object.entries(question.options)) {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                optionElement.textContent = `${key}: ${value}`;
                optionElement.dataset.option = key;

                optionElement.addEventListener('click', function () {
                    // Clear any previous selections
                    document.querySelectorAll('#practiceOptions .option').forEach(opt => {
                        opt.classList.remove('selected', 'correct', 'incorrect');
                    });

                    // Mark this option
                    const isCorrect = key === question.correct_answer;
                    optionElement.classList.add(isCorrect ? 'correct' : 'incorrect');

                    // If incorrect, highlight the correct answer
                    if (!isCorrect) {
                        document.querySelector(`#practiceOptions .option[data-option="${question.correct_answer}"]`)
                            .classList.add('correct');
                    }

                    // Show feedback
                    practiceFeedback.className = `feedback visible ${isCorrect ? 'correct' : 'incorrect'}`;
                    practiceFeedback.textContent = isCorrect ?
                        'Correct! Well done.' :
                        `Incorrect. The correct answer is ${question.correct_answer}.`;
                });

                practiceOptions.appendChild(optionElement);
            }

            // Update navigation buttons
            practicePrevButton.disabled = currentPracticeQuestion === 0;
            practiceNextButton.disabled = currentPracticeQuestion === allQuestions.length - 1;
        }

        // Handle practice navigation
        function handlePracticePrev() {
            if (currentPracticeQuestion > 0) {
                currentPracticeQuestion--;
                displayPracticeQuestion();
            }
        }

        function handlePracticeNext() {
            if (currentPracticeQuestion < allQuestions.length - 1) {
                currentPracticeQuestion++;
                displayPracticeQuestion();
            }
        }

        // Return to home
        function goToHome() {
            mockExamView.style.display = 'none';
            practiceView.style.display = 'none';
            resultsView.style.display = 'none';
            homeView.style.display = 'block';
        }

        // Initialize
        async function initialize() {
            // Load questions
            const loaded = await loadQuestions();
            if (!loaded) {
                alert('Error loading questions. Please try again later.');
                return;
            }

            // Set up event listeners
            startMockExamButton.addEventListener('click', startMockExam);
            startPracticeButton.addEventListener('click', startPractice);
            mockNextButton.addEventListener('click', handleMockNext);
            practicePrevButton.addEventListener('click', handlePracticePrev);
            practiceNextButton.addEventListener('click', handlePracticeNext);
            retryButton.addEventListener('click', startMockExam);
            homeButton.addEventListener('click', goToHome);
            homeFromResultsButton.addEventListener('click', goToHome);
        }

        // Start the app
        initialize();
    </script>
</body>

</html>